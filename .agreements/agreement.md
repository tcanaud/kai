# Agreement System

## The problem

When BMAD produces product artifacts and Spec Kit produces implementation artifacts,
nothing guarantees that the two remain aligned with the delivered code.
The PRD says one thing, the API contract says another, the code does a third.
Drift is invisible until something breaks.

## The solution

An **Agreement** is a lightweight YAML artifact that captures the **shared promise** between:

- **BMAD** (product) — the intent, the why
- **Spec Kit** (implementation) — the plan, the contracts, the how
- **Code** — the delivered reality

The Agreement replaces none of these three. It is the convergence point
that each one references.

> One feature = one Agreement = one explicit promise.

## Architecture

```
project-root/
│
├── .agreements/                          # own space, never touched by BMAD/Spec Kit updates
│   ├── config.yaml                      # project configuration (paths, defaults)
│   ├── agreement.md                     # this file
│   ├── index.yaml                       # registry of all agreements
│   ├── _templates/
│   │   └── agreement.tpl.yaml           # template v1
│   └── ###-feature-name/
│       ├── agreement.yaml               # one agreement per feature
│       └── check-report.md              # drift report (generated by /agreement.check)
│
├── .claude/commands/                    # Claude Code commands
│   ├── agreement.create.md             # namespace "agreement.*" — independent from speckit.*
│   ├── agreement.sync.md
│   ├── agreement.check.md
│   └── agreement.doctor.md
│
├── _bmad/_config/agents/*.customize.yaml # BMAD integration via native mechanism
├── _bmad/_memory/agreements-sidecar/    # persistent memory for BMAD agents
│
├── .bmad_output/                        # BMAD artifacts (not touched)
└── specs/                               # Spec Kit artifacts (not touched except tasks.md by /doctor)
```

**Update resilience**: no core file from BMAD or Spec Kit is modified.
Integration goes through `customize.yaml` (BMAD) and the `agreement.*` namespace (Claude Code),
two extension mechanisms designed to survive updates.

## Commands

| Command | Role | Modifies files? |
|---------|------|----------------|
| `/agreement.create` | Create an Agreement for a feature | `.agreements/` only |
| `/agreement.sync` | Synchronize the Agreement with existing artifacts | `.agreements/` only |
| `/agreement.check` | Verify code against the Agreement promise | Writes `check-report.md` on FAIL |
| `/agreement.doctor` | Generate corrective tasks from a check FAIL | Appends a phase to `tasks.md` |

### `/agreement.create`

Creates an Agreement. Automatically detects existing BMAD and Spec Kit artifacts.

```
/agreement.create Description of the feature
/agreement.create 001-feature-name
```

### `/agreement.sync`

Detects drift between the Agreement and product/implementation artifacts.
Proposes updates, applies only after confirmation.

```
/agreement.sync 001-feature-name
```

### `/agreement.check`

Compares actual code against interfaces and criteria declared in the Agreement.
Returns a PASS or FAIL verdict. On FAIL, writes a structured `check-report.md`.

```
/agreement.check 001-feature-name
/agreement.check diff
```

### `/agreement.doctor`

Reads the `check-report.md`, reads the Spec Kit contracts (source of truth),
and generates corrective tasks in native Spec Kit format.
Tasks are appended to `tasks.md` as an "Agreement Fixes" phase
and are executable by `/speckit.implement`.

```
/agreement.doctor 001-feature-name
```

## Tested user stories

### Story 1 — Creation from scratch (BMAD + Spec Kit + Agreement)

**Context**: starting from zero with a feature idea (BookStore CRUD API)
and producing all artifacts on both sides before creating the Agreement.

**Executed flow**:

```
# 1. Produce BMAD artifacts (product)
/bmad-bmm-create-product-brief            → product-brief.md
/bmad-bmm-create-prd                      → prd.md
/bmad-bmm-create-architecture             → architecture.md
/bmad-bmm-create-epics-and-stories        → epics.md

# 2. Produce Spec Kit artifacts (implementation)
/speckit.specify                          → spec.md
/speckit.plan                             → plan.md, contracts/, data-model.md, research.md
/speckit.tasks                            → tasks.md

# 3. Create the Agreement (convergence)
/agreement.create 001-bookstore-crud-api
```

**Result**: `/agreement.create` detected 4 BMAD artifacts and 7
Spec Kit artifacts. The Agreement was generated with:

- product intent extracted from the PRD
- interfaces extracted from Spec Kit contracts
- acceptance criteria cross-referenced from both sources
- watched_paths covering all 3 layers (BMAD, Spec Kit, code)

**What this proves**: the Agreement can scan both ecosystems
and extract a unified promise from them, without modifying any existing file.

### Story 2 — Contract-first repair (check → doctor → implement → check)

**Context**: the code was implemented via `/speckit.implement` but
diverged from the contracts on 3 points (DELETE 204 vs 200, nested vs flat pagination,
missing string error codes). The drift came from the fact that `tasks.md` did not
explicitly reference the contracts — the implementation agent used the most
common patterns instead of reading `contracts/books-api.md`.

**Executed flow**:

```
# 1. Detect drift
/agreement.check diff
  → FAIL: 3 BREAKING, 2 DRIFT
  → check-report.md written to .agreements/001-bookstore-crud-api/

# 2. Generate corrective tasks
/agreement.doctor 001-bookstore-crud-api
  → reads check-report.md + contracts/books-api.md (source of truth)
  → generates 5 FIX tasks in tasks.md (Phase 7: Agreement Fixes)
  → each task is self-contained: file + current behavior + expected behavior + contract ref

# 3. Execute corrections
/speckit.implement
  → executes FIX tasks like any Spec Kit task
  → marks each task [X] once completed

# 4. Re-verify
/agreement.check 001-bookstore-crud-api
  → PASS
```

**What this proves**:

1. `/agreement.check` detects real gaps between the promise and the code, statelessly
2. `/agreement.doctor` translates those gaps into tasks that Spec Kit consumes natively
3. The check → doctor → implement → check cycle loops until PASS
4. No core BMAD or Spec Kit file was modified — only `tasks.md` received a corrective phase

**Root cause identified**: the drift was not in the specs or in the contracts
(which were precise) but in `tasks.md` which did not reference the contracts.
The signal degraded in the last mile: `contract (precise) → tasks (vague) → code (diverged)`.
The Agreement System is the safety net that catches this loss.

## Principles

1. **Short** — an Agreement is ~50 lines of YAML. It captures the promise, not the details.
2. **Reference, don't duplicate** — details stay in the PRD (BMAD) and the spec (Spec Kit).
3. **Agreement-first** — any interface change goes through the Agreement first.
4. **Never silent** — `/agreement.sync` proposes, the user confirms.
5. **Progressive** — an Agreement can be created at any point in the cycle.
6. **Resilient** — no dependency on core files of third-party tools.
